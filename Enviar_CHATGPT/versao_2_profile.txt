import { supabase } from '../lib/supabase';

export interface UserProfile {
    id?: number;
    client_id: string; // Kept for backward compatibility
    user_id?: string;  // The new standard
    display_name: string;
    email: string;
    avatar_url: string | null;
}

const DEFAULT_AVATAR = 'https://lh3.googleusercontent.com/aida-public/AB6AXuCL1O9wbtqdBrh5xAbgG-NoBUL-m5ewCL0_hOmAX4hUbSmx_uoRnfwgjJO8WfBcOzxb3vM33epDc1aJfgMMrzCOv2yYEcryOkye1Fa7ThGR-d4KZXoSDKCJpK_TyENI_eEMKsbMpXQAMyb1vfYDXQ_WGAmhgiS9RxYwJAYNWhq5KL7Au2Nz61qfhAPECL0S1tO0JkGDLLYi857vZ65T5Si4q_kDW0bXspwks0Qk3cMRIntjK3nage2sbJsW2WdOOUejDB7fhG00h1M';

export const ProfileService = {
    async getProfile(passedSession?: { access_token: string; user: { id: string; email?: string; user_metadata?: any } }): Promise<UserProfile> {
        try {
            let session = passedSession;
            if (!session) {
                const { data } = await supabase.auth.getSession();
                session = data.session as any;
            }
            if (!session) throw new Error('No active session');

            const userId = session.user.id;
            const email = session.user.email || '';
            const accessToken = session.access_token;

            console.log('[ProfileService] EXECUTING RAW FETCH for user_id:', userId);

            // Raw Fetch Bypass - Diagnosing Library Hang
            // Using implicit env vars if available, or the hardcoded url/key from supabase.ts logic would be better but we don't import them.
            // We'll trust the VITE envs are present or use the ones we saw in supabase.ts
            const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || 'https://orpdpcvwwftnncsyzbwq.supabase.co';
            const supabaseKey = import.meta.env.VITE_SUPABASE_KEY || 'sb_publishable_kISpxfZJHmxn4uzC1NeELg_thEVRNWA';

            const response = await fetch(`${supabaseUrl}/rest/v1/user_profiles?user_id=eq.${userId}&select=*`, {
                method: 'GET',
                headers: {
                    'apikey': supabaseKey,
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                    'Prefer': 'return=representation' // Make sure we get data back
                    // 'Accept': 'application/vnd.pgrst.object+json' // Optional: ask for single object
                }
            });

            console.log('[ProfileService] Raw Fetch Status:', response.status);

            if (!response.ok) {
                const errorText = await response.text();
                console.error('[ProfileService] Rest API Error:', errorText);
                throw new Error(`Fetch failed: ${response.status} ${errorText}`);
            }

            const rows = await response.json();
            console.log('[ProfileService] Raw Fetch Data:', rows);

            let data = rows[0]; // Since we didn't ask for single object explicitly via header 'Accept: application/vnd.pgrst.object+json'

            if (!data) {
                // Profile missing, create new one
                console.log('[ProfileService] Profile missing (empty array), creating new record...');
                return this.createProfile(userId, email, session.user.user_metadata?.display_name);
            }

            return {
                ...data,
                avatar_url: data.avatar_url || DEFAULT_AVATAR
            };

        } catch (error) {
            console.error('[ProfileService] Error fetching profile:', error);
            throw error;
        }
    },

    async createProfile(userId: string, email: string, displayName?: string): Promise<UserProfile> {
        // ✅ FIX: Ensure user_id is populated on creation
        const newProfile = {
            client_id: userId, // Legacy support
            user_id: userId,   // Critical for RLS
            display_name: displayName || 'Colega Médico',
            email: email,
            avatar_url: null
        };

        const supabaseUrl = import.meta.env.VITE_SUPABASE_URL || 'https://orpdpcvwwftnncsyzbwq.supabase.co';
        const supabaseKey = import.meta.env.VITE_SUPABASE_KEY || 'sb_publishable_kISpxfZJHmxn4uzC1NeELg_thEVRNWA';

        try {
            // Raw Fetch Bypass for Upsert
            const { data: { session } } = await supabase.auth.getSession();
            const token = session?.access_token; // Use current token

            console.log('[ProfileService] Creating profile via RAW FETCH (Upsert)', newProfile);

            const response = await fetch(`${supabaseUrl}/rest/v1/user_profiles`, {
                method: 'POST',
                headers: {
                    'apikey': supabaseKey,
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Prefer': 'return=representation,resolution=merge-duplicates' // Equivalent to upsert
                },
                body: JSON.stringify(newProfile)
            });

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(`Profile creation failed: ${response.status} ${errText}`);
            }

            const rows = await response.json();
            const data = rows[0];

            return {
                ...data, // This will include the full record
                avatar_url: data.avatar_url || DEFAULT_AVATAR
            };
        } catch (error) {
            console.error('Error creating profile (REST):', error);
            // Fallback object to not block auth
            return {
                client_id: userId,
                user_id: userId,
                display_name: 'Usuário',
                email: email,
                avatar_url: DEFAULT_AVATAR
            };
        }
    },

    async updateProfile(updates: Partial<UserProfile>): Promise<boolean> {
        try {
            const { data: { session } } = await supabase.auth.getSession();
            if (!session) return false;

            const { error } = await supabase
                .from('user_profiles')
                .update({
                    ...updates,
                    updated_at: new Date().toISOString()
                })
                .eq('user_id', session.user.id); // ✅ FIX: Update by user_id

            if (error) throw error;
            return true;
        } catch (error) {
            console.error('Error updating profile:', error);
            return false;
        }
    },

    async uploadAvatar(file: File): Promise<string | null> {
        try {
            const { data: { session } } = await supabase.auth.getSession();
            if (!session) return null;

            const userId = session.user.id;
            const fileExt = file.name.split('.').pop();
            const fileName = `${userId}-${Date.now()}.${fileExt}`;

            // Upload image
            const { error: uploadError } = await supabase.storage
                .from('avatars')
                .upload(fileName, file, {
                    cacheControl: '3600',
                    upsert: true
                });

            if (uploadError) throw uploadError;

            // Get public URL
            const { data: { publicUrl } } = supabase.storage
                .from('avatars')
                .getPublicUrl(fileName);

            // Update profile
            await supabase
                .from('user_profiles')
                .update({
                    avatar_url: publicUrl,
                    updated_at: new Date().toISOString()
                })
                .eq('user_id', userId); // ✅ FIX: Update by user_id

            return publicUrl;
        } catch (error) {
            console.error('Error uploading avatar:', error);
            return null;
        }
    }
};
